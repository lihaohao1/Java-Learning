# 浅谈java继承
---
*java作为面向对象设计语言有三大特性：封装、继承和多态性。继承是面向对象语言的重要特征，没有继承的语言只能被称作“使用对象语言”，继承是简单而强大的设计思想，它提供了我们代码重用和程序组织的有力工具。*
*类是规则，用来制造对象的规则。我们定义类并用类制造一些对象。类限定了对象的属性和行为。像图纸决定了房子要建造成什么样。一张图纸可以用很多次，可以盖很多房子，但是每个房子都有少许的差别，难道我们每次盖房子都要重新画图纸吗？这显然是不现实的，只用将之前的图纸拿出来做相应的修改就行，既减轻了工作量也降低了出错的可能。*

在java的继承中，新的类不是重新产生的，而是基于某一个已存在的类。通过继承，新的类获得基础类中**除构造方法外所有的成员——成员变量和成员方法**，无论属性是public还是private，但是**得到不等于可以随便使用**。
|  父类成员访问属性  |  在父类中  |  在子类中  |
|-|
|  public  |  对所有人开放  |  对所有人开放  |
|  protected|  包内其他类、自己、子类可以访问 |包内其他类、自己、子类可以访问 |
|缺省|只有包内其他类可以访问|子类与父类在同一个包内可以访问|
|private|只有自己访问|不能直接访问|
我们把基础类派生其他类的那个类叫做父类、超类或基类，派生的新类叫做子类，用extends关键字表示这种继承/派生关系。

在构造一个子类的对象时，父类的构造方法也是会被调用的，而且**父类的构造方法在子类的构造方法之前被调用**。在程序运行过程中，子类对象的一部分空间存放的是父类对象。因为子类从父类得到继承，在子类对象初始化过程中可能会使用到父类的成员。所以父类的空间正是要先被初始化的，然后子类的空间才得到初始化。

说到继承，不得不提的就是两个关键字**this**和**super**

this指向当前对象本身，在形参与成员名字重名时，用this.x来区分
super指向当前对象的父类，super.x用来指代父类中的可访问的变量或方法

类中的构造函数会根据传递的参数，自动选择不同的构造函数
this可以调用**本类中另一种形式**的构造函数（位于构造函数第一条语句）
super调用**父类**中的某一个构造函数（位于构造函数第一条语句）

## 多态变量 与 造型cast
>java的对象变量是多态的，能保存不止一种类型的对象,可以保存声明类型的对象或声明类型的子类的对象
当把子类的对象赋给父类的变量的时候就发生了向上造型

```graphLR
A(Vehicle)-->B(Car)
A-->C(Bicycle)
```
```java
ArrayList<Vehicle> vehicleList = new ArrayList<Vehicle>();
public void add（Vehicle v）//若传递的对象类型为car或bicycle时，就发生了向上造型
{
     vehicleList.add(v);
}

//子类的对象可以赋值给父类的变量
Vehicle v1 = new Car();   
Vehicle v2 = new Bicycle();

//子类的对象可以传递给需要父类对象的函数，也可以保存在容器中
Car v3 = new Car();
add(v3);
--------------------------------------------------------------------------
Vechicle v;
Car c = new Car();
v = c;//可以
c = v;//编译错误 可用c = （Car）v;此时发生了造型，只有当v实际管理Car才行
```

## 覆盖Override
>子类和父类中存在**名称和参数表完全相同**的函数，这一对函数构成覆盖关系。对于外界来说，子类并没增加新的方法，仍然是在父类中定义过的那个方法，子类的对象调用这个方法时执行的是子类自己的方法。父类对象调用执行父类的方法，通过父类的变量调用覆盖关系的函数时，调用变量当时管理的对象所属的类的函数。
当调用一个方法时，究竟应该调用哪个方法，这件事情叫做绑定。绑定表明了调用一个方法的时候，我们使用的是哪个方法。绑定有两种：一种是早绑定，又称**静态绑定**(根据变量的声明类型)，这种绑定在*编译*的时候就确定了；另一种是晚绑定，即**动态绑定**（根据变量的动态类型）。动态绑定在*运行*的时候根据变量当时实际所指的对象的类型动态决定调用的方法。Java缺省使用动态绑定。
```java
class Vechicle
{
   public void show()
   {
    System.out.println("a");
   }
}
class Car extends Vechicle
{
    public void show()
    {
     System.out.println("b");
    }
}
public class test
{
    Vechicle a = new Vechicle();
    Vechicle b = new Car();  //向上造型
    a.show(); //a
    b.show(); //b,虽然属于Vechicle,实际上还是Car
}
```



